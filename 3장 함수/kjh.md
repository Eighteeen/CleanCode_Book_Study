# 3장 함수

## ✨ 발생시킨 이슈 리스트
- [[함수] - 3-2 예제가 3-1 코드와 정말 같은 동작을 하는지?](https://github.com/Eighteeen/CleanCode_Book_Study/issues/4)

- [[함수] - '추상화 수준' 이라는 개념을 좀 더 명확하게 설명하자면 어떻게 설명해야 할까?](https://github.com/Eighteeen/CleanCode_Book_Study/issues/5)

- [[부수효과를 일으키지 마라!] - 시간적 결합과 순서 종속성에 대한 정확한 뜻](https://github.com/Eighteeen/CleanCode_Book_Study/issues/6)

- [[명령과 조회를 분리하라!] - 이 원칙을 우리 백준 풀이 코드에 적용한다면?](https://github.com/Eighteeen/CleanCode_Book_Study/issues/7)

## 🎞 회고  

### 9월 27일
* 이제 제대로 시작하는 느낌. '추상화 수준'이라는 개념 잡는게 꽤 어려웠다.
* 이번 스터디 이전에 클린코드 책을 몇번 들춰봤던 경험 상, 코드를 그저 읽기만 해선 별 얻어가는 게 없더라. 그래서 이번엔 코드 한 줄 한 줄 주석으로 해석해가며 읽어봤다.
    * 읽는 과정에서 옥의 티를 찾아내기도 했다.
    * 이렇게 꼼꼼히 읽으니까 더 기억에 잘 남는 느낌이 들기도 한다.

### 10월 3일
* 시간적 결합, 순서 종속성이 대체 무슨 용어인가~ 했는데 이 중 순서 종속성은 용어같은게 아니었다.
	* order dependency를 순서 종속성으로 번역된 것이고
	* 그냥 문자 그대로 순서 의존성, 순서 종속성의 뜻을 말하는 것 같더라.
* '명령과 조회를 구분하라' 파트에서 벽을 느꼈다.
	* 분명 실무에서 이 부분을 다루는 어떤 요령같은 게 있을거라 생각한다.
	* 근데 책, 검색으로는 그런 요령을 찾을 수가 없다.
	* 물어볼 실무자가 곁에 있었으면 좋았을텐데.
* '재귀라는 기교' 이슈에서 내가 오독했다는 걸 깨달았다.
	* 빠르게 읽다보니 내멋대로 이해하고 넘어간 것 같더라.
	* 조금은 꼼꼼히 읽어야겠다.

## 개인적으로 정리한 내용

### 서문
* 어떤 프로그램이든 가장 기본적인 단위가 함수다. 이 장은 함수를 잘 만드는 법을 소개한다.

### 작게 만들어라!
* 함수를 만드는 첫째 규칙은 ‘작게’!다. 둘째 규칙은 ‘더 작게!’다.
* 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.

### 한 가지만 해라!
* 함수는 한 가지를 해야 한다.
* 그 한 가지를 잘 해야 한다.
* 그 한 가지만을 해야 한다.
* 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.
	* 어쨌거나 우리가 함수를 만드는 이유는 큰 개념을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서가 아니던가.
* 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.

### 함수 당 추상화 수준은 하나로!
* getHtml()은 추상화 수준이 아주 높다.
* String pagePathName = PathParser.render(pagepath);는 추상화 수준이 중간이다.
* .append(‘\n’)과 같은 코드는 추상화 수준이 아주 낮다.

* 코드는 위에서 아래로 이야기처럼 읽혀야 좋다 (위에서 아래로 코드 읽기: 내려가기 규칙)
	* 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.

### Switch 문
* 본질적으로 switch 문은 N가지를 처리한다.
* 불행하게도 switch 문을 완전히 피할 방법은 없다.
* 하지만 각 switch 문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법은 있다.
	* 추상 팩토리 메서드에서만 switch 문을 사용하는 것이다.
		* 다형적 객체를 생성할 때

### 서술적인 이름을 사용하라!
* 좋은 이름이 주는 가치는 아무리 강조해도 지나치지 않다.
* 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.
* 이름을 붙일 때는 일관성이 있어야 한다.

### 함수 인수
* 함수에서 이상적인 인수 개수는 0개다. 다음은 1개고, 다음은 2개다.
* 3개는 가능한 피하는 편이 좋다. 4개 이상은 특별한 이유가 필요하다.
* 인수는 어렵다.
	* 인수는 개념을 이해하기 어렵게 만든다.
	* 테스트 관점에서 보면 인수는 더 어렵다.
	* 출력 인수는 입력 인수보다 이해하기 어렵다.
		* 최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개뿐인 경우다.
			* SetupTeardownIncluder.render(pageData)는 이해하기 아주 쉽다.
			* pageData 객체 내용을 렌더링 하겠다는 뜻이다.

많이 쓰는 단항 함수 형식
1. 인수에 질문을 던지는 경우 boolean fileExists(String)
2. 인수를 변환해 결과를 반환하는 경우 InputStream fileOpen(String)

드물게 사용하지만 아주 유용한 단항 함수 형식
* 이벤트 함수 passwordAttemptFailedNtimes(int attempts)

* 위의 세 경우가 아니라면 단항 함수는 가급적 피한다.

플래그 인수
* 플래그 인수는 추하다.
* 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈이니까!
* 원래는 renderForSuite()와 renderForSingleTest()라는 함수로 나눠야 마땅하다.

이항 함수
* 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
* 물론 이항 함수가 적절한 경우도 있다. Point p = new Point(0, 0)
* 그만큼 위험이 따른다는 사실을 이해하고 가능하면 단항 함수로 바꾸도록 애써야 한다.
	1. 필요한 매개변수 객체의 멤버 메서드로 만들기
	2. 필요한 매개변수를 멤버변수로 만들기
	3. 필요한 매개변수를 생성자에서 받는 새 클래스를 만들고 그 안에서 메서드를 구현하기

삼항 함수
* 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다.
* 순서, 주춤, 무시로 야기되는 문제가 두 배 이상 늘어난다. 그래서 삼항 함수를 만들 때는 신중히 고려하라 권고한다.
* assertEquals(message, expected, actual)
	* 매번 함수를 볼 때마다 주춤했다가 message를 무시해야 한다는 사실을 상기했다
* assertEquals(1.0, amount, .001)
	* 여전히 주춤하게 되지만 그만한 가치가 충분하다.
	* 부동소수점 비교가 상대적이라는 사실은 언제든 주지할 중요한 사항이다.

인수 객체
* 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.
	* (double x, double y, double radius) -> (Point center, double radius)

인수 목록
* 때로는 인수 개수가 가변적인 함수도 필요하다. String.format
	* String.format은 사실상 이항 함수다.
* 가변 인수를 취하는 함수는 단항, 이항, 삼항 함수로 취급할 수 있다.

동사와 키워드
* 함수의 의도, 인수의 순서, 인수의 의도를 제대로 표현하려면 좋은 함수 이름이 필수다
* 단항 함수 -> 함수명과 인수명이 동사/명사 쌍을 이뤄야 한다
	* write(name)
	* writeField(name)
* 함수 이름에 키워드를 추가하는 형식
	* assertEquals(expected, actual)보다
	* assertExpectedEqualsActual(expected, actual)이 더 좋다.
	* 그러면 인수 순서를 기억할 필요가 없어진다.

### 부수효과를 일으키지 마라!
* 부수 효과는 거짓말이다.
* 함수에서 한 가지를 하겠다고 약속하고선 남몰래 다른 짓도 하니까.
* 많은 경우 시간적인 결합이나 순서 종속성을 초래한다
+ 시간적인 결합
+ 순서 종속성
* 객체 지향 언어에서는 출력 인수를 사용할 필요가 거의 없다. 출력 인수로 사용하라고 설계한 변수가 바로 this이기 떄문이다.

### 명령과 조회를 분리하라!
* 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 둘 다 하면 안 된다.
* 객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나다.
- 우리 코드

### 오류 코드보다 예외를 사용하라!
* 오류 코드를 반환하면 호출자는 오류 코드를 곧바로 처리해야 한다는 문제에 부딪힌다.
* 반면 오류 코드 대신 예외를 사용하면 오류 처리 코드가 분리되므로 코드가 깔끔해진다.
* try/catch 블록은 원래 추하다. 그러므로 별도 함수로 뽑아내는 편이 좋다.
	* 함수는 한 가지 작업만 해야 한다. 오류 처리도 한 가지 작업에 속한다.
	* 그러므로 오류를 처리하는 함수는 오류만 처리해야 마땅하다.
* 오류 코드를 정의한 enum는 의존성 자석이다. 다른 클래스에서 import해 사용해야 하므로.
	* Error enum이 변한다면 Error enum을 사용하는 클래스 전부를 다시 컴파일하고 다시 배치해야 한다.
* 오류 코드 대신 예외를 사용하면 새 예외는 Exception 클래스에서 파생된다.
	* 따라서 재컴파일/재배치 없이도 새 예외 클래스를 추가할 수 있다.

### 반복하지 마라!
* 어쩌면 중복은 소프트웨어에서 모든 악의 근원이다.
* 많은 원칙과 기법이 중복을 없애거나 제어할 목적으로 나왔다.
* 소프트웨어 개발에서 지금까지 일어난 혁신은 소스 코드에서 중복을 제거하려는 지속적인 노력으로 보인다.

### 구조적 프로그래밍
* 함수를 작게 만든다면 return, break, continue를 여러 차례 사용해도 괜찮다.
* 오히려 때로는 단일 입/출구 규칙보다 의도를 표현하기 쉬워진다.
* goto는 피한다.

### 함수를 어떻게 짜죠?
* 처음에는 길고 복잡하다. 하지만 나는 단위 테스트 케이스도 만든다.
* 나는 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다. 메서드를 줄이고 순서를 바꾼다. 때로는 전체 클래스를 쪼개기도 한다.
* 이 와중에도 코드는 항상 단위 테스트를 통과한다.
* 최종적으로는 이 장에서 설명한 규칙을 따르는 함수가 얻어진다.
* 처음부터 탁 짜내지 않는다. 그게 가능한 사람은 없으리라.

### 결론
* 프로그래밍의 기술은 언제나 언어 설계의 기술이다.
* 대가 프로그래머는 시스템을 ‘구현할 프로그램’이 아니라 ‘풀어갈 이야기’로 여긴다.
	* 프로그래밍 언어라는 수단을 사용해 좀 더 풍부하고 좀 더 표현력인 강한 언어를 만들어 이야기를 풀어간다.
	* 함수 계층이 바로 그 언어에 속한다.
	* 여러 기교로 각 동작은 자신만의 이야기를 풀어간다.
* 이 장은 함수를 잘 만드는 기교를 소개했다.
	* 여기서 설명한 규칙을 따른다면 길이가 짧고, 이름이 좋고, 체계가 잡힌 함수가 나오리라.
	* 하지만 진짜 목표는 시스템이라는 이야기를 풀어가는 데 있다는 사실을 명심하기 바란다.
