# 3장 함수

## ✨ 발생시킨 이슈 리스트
- [[함수] - 3-2 예제가 3-1 코드와 정말 같은 동작을 하는지?](https://github.com/Eighteeen/CleanCode_Book_Study/issues/4)

- [[함수] - '추상화 수준' 이라는 개념을 좀 더 명확하게 설명하자면 어떻게 설명해야 할까?](https://github.com/Eighteeen/CleanCode_Book_Study/issues/5)

## 🎞 회고  

### 9월 27일
* 이제 제대로 시작하는 느낌. '추상화 수준'이라는 개념 잡는게 꽤 어려웠다.
* 이번 스터디 이전에 클린코드 책을 몇번 들춰봤던 경험 상, 코드를 그저 읽기만 해선 별 얻어가는 게 없더라. 그래서 이번엔 코드 한 줄 한 줄 주석으로 해석해가며 읽어봤다.
    * 읽는 과정에서 옥의 티를 찾아내기도 했다.
    * 이렇게 꼼꼼히 읽으니까 더 기억에 잘 남는 느낌이 들기도 한다.

## 개인적으로 정리한 내용

### 서문
* 어떤 프로그램이든 가장 기본적인 단위가 함수다. 이 장은 함수를 잘 만드는 법을 소개한다.

### 작게 만들어라!
* 함수를 만드는 첫째 규칙은 ‘작게’!다. 둘째 규칙은 ‘더 작게!’다.
* 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.

### 한 가지만 해라!
* 함수는 한 가지를 해야 한다.
* 그 한 가지를 잘 해야 한다.
* 그 한 가지만을 해야 한다.
* 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.
	* 어쨌거나 우리가 함수를 만드는 이유는 큰 개념을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서가 아니던가.
* 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.

### 함수 당 추상화 수준은 하나로!
* getHtml()은 추상화 수준이 아주 높다.
* String pagePathName = PathParser.render(pagepath);는 추상화 수준이 중간이다.
* .append(‘\n’)과 같은 코드는 추상화 수준이 아주 낮다.

* 코드는 위에서 아래로 이야기처럼 읽혀야 좋다 (위에서 아래로 코드 읽기: 내려가기 규칙)
	* 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.

### Switch 문
* 본질적으로 switch 문은 N가지를 처리한다.
* 불행하게도 switch 문을 완전히 피할 방법은 없다.
* 하지만 각 switch 문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법은 있다.
	* 추상 팩토리 메서드에서만 switch 문을 사용하는 것이다.
		* 다형적 객체를 생성할 때

### 서술적인 이름을 사용하라!
* 좋은 이름이 주는 가치는 아무리 강조해도 지나치지 않다.
* 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.
* 이름을 붙일 때는 일관성이 있어야 한다.

### 함수 인수
* 함수에서 이상적인 인수 개수는 0개다. 다음은 1개고, 다음은 2개다.
* 3개는 가능한 피하는 편이 좋다. 4개 이상은 특별한 이유가 필요하다.
* 인수는 어렵다.
	* 인수는 개념을 이해하기 어렵게 만든다.
	* 테스트 관점에서 보면 인수는 더 어렵다.
	* 출력 인수는 입력 인수보다 이해하기 어렵다.
		* 최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개뿐인 경우다.
			* SetupTeardownIncluder.render(pageData)는 이해하기 아주 쉽다.
			* pageData 객체 내용을 렌더링 하겠다는 뜻이다.

많이 쓰는 단항 함수 형식
1. 인수에 질문을 던지는 경우 boolean fileExists(String)
2. 인수를 변환해 결과를 반환하는 경우 InputStream fileOpen(String)

드물게 사용하지만 아주 유용한 단항 함수 형식
* 이벤트 함수 passwordAttemptFailedNtimes(int attempts)

* 위의 세 경우가 아니라면 단항 함수는 가급적 피한다.

플래그 인수
* 플래그 인수는 추하다.
* 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈이니까!
* 원래는 renderForSuite()와 renderForSingleTest()라는 함수로 나눠야 마땅하다.

이항 함수
* 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
* 물론 이항 함수가 적절한 경우도 있다. Point p = new Point(0, 0)
* 그만큼 위험이 따른다는 사실을 이해하고 가능하면 단항 함수로 바꾸도록 애써야 한다.
	1. 필요한 매개변수 객체의 멤버 메서드로 만들기
	2. 필요한 매개변수를 멤버변수로 만들기
	3. 필요한 매개변수를 생성자에서 받는 새 클래스를 만들고 그 안에서 메서드를 구현하기

삼항 함수
* 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다.
* 순서, 주춤, 무시로 야기되는 문제가 두 배 이상 늘어난다. 그래서 삼항 함수를 만들 때는 신중히 고려하라 권고한다.
* assertEquals(message, expected, actual)
	* 매번 함수를 볼 때마다 주춤했다가 message를 무시해야 한다는 사실을 상기했다
* assertEquals(1.0, amount, .001)
	* 여전히 주춤하게 되지만 그만한 가치가 충분하다.
	* 부동소수점 비교가 상대적이라는 사실은 언제든 주지할 중요한 사항이다.

인수 객체
* 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.
	* (double x, double y, double radius) -> (Point center, double radius)

인수 목록
* 때로는 인수 개수가 가변적인 함수도 필요하다. String.format
	* String.format은 사실상 이항 함수다.
* 가변 인수를 취하는 함수는 단항, 이항, 삼항 함수로 취급할 수 있다.

동사와 키워드
* 함수의 의도, 인수의 순서, 인수의 의도를 제대로 표현하려면 좋은 함수 이름이 필수다
* 단항 함수 -> 함수명과 인수명이 동사/명사 쌍을 이뤄야 한다
	* write(name)
	* writeField(name)
* 함수 이름에 키워드를 추가하는 형식
	* assertEquals(expected, actual)보다
	* assertExpectedEqualsActual(expected, actual)이 더 좋다.
	* 그러면 인수 순서를 기억할 필요가 없어진다.